var documenterSearchIndex = {"docs":
[{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"EditURL = \"../../lit/examples/joss_demo.jl\"","category":"page"},{"location":"generated/joss_demo/#example_script","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"","category":"section"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"This page gives a step-by-step demonstration of an example script for using GIRFReco.jl, which consists of the following two files:","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"A Julia script of an example pipeline for spiral reconstruction: joss_demo.jl\nA configuration file which defines parameters for the spiral reconstruction: recon_config_joss_demo.jl","category":"page"},{"location":"generated/joss_demo/#.-Quick-Start","page":"GIRFReco.jl Example Script","title":"0. Quick Start","text":"","category":"section"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"To have a quick run of the example, simply take the following steps.","category":"page"},{"location":"generated/joss_demo/#(1)-Cloning-the-package","page":"GIRFReco.jl Example Script","title":"(1) Cloning the package","text":"","category":"section"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"Download or clone the repo to your local by:","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"git clone git@github.com:BRAIN-TO/GIRFReco.jl.git","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"Then enter the example folder:","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"cd GIRFReco.jl/example","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"Alternatively, for the one who are using Visual Studio Code, simply open the example sub-folder from the Menu option File -> Open Folder....","category":"page"},{"location":"generated/joss_demo/#(2)-Run-in-Julia-REPL","page":"GIRFReco.jl Example Script","title":"(2) Run in Julia REPL","text":"","category":"section"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"We recommend to use Visual Studio Code with Julia extension (steps of installation can be found here) to avoid possible image displaying issue, especially for those using SSH and X11 forwarding.","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"The Julia REPL can be launched from the Command Palette (For Windows and Linux: Press Shift + Ctrl + P; For Mac: Press Shift + Command + P) by searching the command Julia: Start REPL.","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"In the launched REPL, simpley execute the following command after launching REPL to run the whole demonstration script (including data download):","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"include(\"run_example.jl\")","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"If you only want to download the demonstration dataset, run:","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"include(\"download_data.jl\")","category":"page"},{"location":"generated/joss_demo/#(3)-After-your-first-example-running...","page":"GIRFReco.jl Example Script","title":"(3) After your first example running...","text":"","category":"section"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"\"Watch a movie, or be part of it\". You are also encouraged to play around with the configuration file and see how (and why) the results are changed. For example:","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"(1) How the results change when we turn off the B₀ correction (by setting do_correct_with_b0_map as false)?","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"(2) What will the images look like when we turn off the zeroth and/or the first order GIRF correction (set do_correct_with_girf_k0 and/or do_correct_with_girf_k1 as false)?","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"(3) Try reconstruction with multiple spiral interleaves by enabling line 97.","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"And so many more options to explore...","category":"page"},{"location":"generated/joss_demo/#.-Setup","page":"GIRFReco.jl Example Script","title":"1. Setup","text":"","category":"section"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"The necessary Julia packages needed for spiral reconstruction.","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"#Our developed packages\nusing GIRFReco, MRIGradients\n\n#MRIReco and its sub-packages\nusing MRIReco, FileIO, MRIFiles, MRIBase, MRICoilSensitivities\n\nusing RegularizedLeastSquares, Flux\n\nusing ImageTransformations\n\nusing PlotlyJS, Plots","category":"page"},{"location":"generated/joss_demo/#.-Configurations-for-reconstruction","page":"GIRFReco.jl Example Script","title":"2. Configurations for reconstruction","text":"","category":"section"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"The following file, recon_config_joss_demo.jl, includes general configuration for spiral reconstruction. It is necessary to execute this file to make sure all parameters are loaded. Sample Data that works with this script can be found here. Please download, extract and set the root_project_path as the top level folder (should be something like /your/path/joss_data_zenodo/)","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"root_project_path = \"/your/path/joss_data_zenodo/\" # Root path of the data extracted from Zenodo\ninclude(\"recon_config_joss_demo.jl\")\n\nplotlyjs()","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"Two parameters determining whether we want to reload the raw data of spiral and GIRF.","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"reload_spiral_data = true; # Set true if we need to reload raw data compulsively.\nreload_girf_data = true; # Set true if we need to reload GIRF data compulsively.\nnothing #hide","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"Choose Slice ([single number] OR [1, 2, 31, ...]） Leave an empty array ([]) or remove this line to select all slices","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"slice_choice = [];\nnothing #hide","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"Choose which diffusion directions and averages to be processed. Diffusion direction index starts from 0 (b=0) to the total number in MDDW protocol (e.g. for 6 diffusion directions, 1-6 stands for 6 DWIs). Index for average starts from 1.","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"diffusion_direction = 0\nidx_average = 1\nnum_total_diffusion_directions = params_general[:num_total_diffusion_directions]\n\n# Determine to reconstruct single-interleave data, or one interleave out of multi-interleave data.\nis_single_interleave = isa(params_general[:scan_fullpath], String)","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"Choose which interleave to be reconstructed.","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"For multi-interleave data, the range of this value is [1:num_total_interleaves].","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"For single-interleave data, it should always be set as 1; for multi-interleave data, the value set here will be used, indicating which interleaves to be merged and reconstructed.","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"start_idx_interleave = 1;\nnothing #hide","category":"page"},{"location":"generated/joss_demo/#.-Image-Reconstruction","page":"GIRFReco.jl Example Script","title":"3. Image Reconstruction","text":"","category":"section"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"The steps of image reconstruction starts here.","category":"page"},{"location":"generated/joss_demo/#.1-Calculation-of-B-and-Coil-Sensitivity-Maps","page":"GIRFReco.jl Example Script","title":"3.1 Calculation of B₀ and Coil Sensitivity Maps","text":"","category":"section"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"The first step in reconstruction pipeline is to calculate the off-resonance (B₀) maps b0_map and coil sensitivity maps cartesian_sensitivity through the Cartesian reconstruction script cartesian_recon.jl.","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"Ideally this script is execute once and the calculated maps are saved into files, which are loaded for future usage to save calculation time. This is controlled by do_load_maps in general parameters.","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"if params_general[:do_load_maps] && isfile(params_general[:b0_map_save_fullpath])\n    @info \"Loading SENSE and B₀ maps from $(params_general[:sensitivity_save_fullpath]) and $(params_general[:b0_map_save_fullpath])\"\n    cartesian_sensitivity = load_map(params_general[:sensitivity_save_fullpath]; do_split_phase = true)\n    b0_maps = load_map(params_general[:b0_map_save_fullpath])\n    num_slices = size(b0_maps, 3)\nelse\n    @info \"Running cartesian_recon to retrieve maps (cartesian_sensitivity and b0_maps)\"\n    cartesian_sensitivity, b0_maps = run_cartesian_recon(params_general)\n    num_slices = size(b0_maps, 3)\nend","category":"page"},{"location":"generated/joss_demo/#.2-Preparation-of-Spiral-Reconstruction","page":"GIRFReco.jl Example Script","title":"3.2 Preparation of Spiral Reconstruction","text":"","category":"section"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"With off-resonance (B₀) maps and coil sensitivity maps calculated, before the reconstruction of spiral images, there are necessary steps to prepare for the related data.","category":"page"},{"location":"generated/joss_demo/#.2.1-Data-Selection","page":"GIRFReco.jl Example Script","title":"3.2.1 Data Selection","text":"","category":"section"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"The first step is to select the part of spiral k-space data that we would like to reconstruct. This include selecting slices, diffusion directions, and averages that we want.","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"First we sort the slice index that we selected to reconstruct.","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"if isempty(slice_choice) || !(@isdefined slice_choice)\n    slice_choice = collect(1:num_slices)\nend\n\nis_multislice = length(slice_choice) > 1\n\nif !is_multislice\n    selected_slice = slice_choice\nelse\n    selected_slice = sort(vec(slice_choice))\nend","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"Next we select the data we would like to reconstruct from the ISMRMRD file.","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"The ISMRMRD data are stored in the following loops:","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"Slice 1, Slice 2 ... Slice N   Slice 1, Slice 2 ... Slice N     Slice 1, Slice 2 ... Slice N ...","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"|______ Diff Dir 1 ______|   |______ Diff Dir 2 ______| ... |______ Diff Dir N ______| ...","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"|_________________________________ Average 1 ___________________________________| ... |___ Average N___|","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"Here we chose the set corresponding to the b-value = 0 images under the first average as the example.","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"Note that (1) The raw data file begins with a series of pre-scan profiles with a length of num_slices*2 and we want to skip them; (2) There is a B1 measurement data profile between each k-space readout profile which also need to be skipped. Thus the reading of data profiles starts from num_slices*2 + 2 with an increment of 2.","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"excitation_list = collect(num_slices*2+2:2:num_slices*4) .+ diffusion_direction * num_slices * 2 .+ (idx_average - 1) * num_slices * (num_total_diffusion_directions + 1) * 2\nslice_selection = excitation_list[selected_slice]","category":"page"},{"location":"generated/joss_demo/#.2.2-Synchronizing-and-Merging-of-k-space-Data-and-Trajectory","page":"GIRFReco.jl Example Script","title":"3.2.2 Synchronizing and Merging of k-space Data and Trajectory","text":"","category":"section"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"Since the k-space data and spiral k-space trajectories are sampled under different sampling rates and stored in separate files, they need to be first synchronized into the frequency of k-space data and then merged into a single object before final spiral image reconstruction.","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"Here we use a dictionary params_spiral to hold the parameters for this k-space data/trajectory synchronization and merging.","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"params_spiral = Dict{Symbol,Any}()\nparams_spiral[:recon_size] = Tuple(params_general[:recon_size])\nparams_spiral[:interleave] = start_idx_interleave\nparams_spiral[:num_samples] = params_general[:num_adc_samples]\nparams_spiral[:delay] = 0.00000\nparams_spiral[:interleave_data_filenames] = params_general[:scan_fullpath]\nparams_spiral[:traj_filename] = params_general[:gradient_fullpath]\nparams_spiral[:excitations] = slice_selection\nparams_spiral[:do_multi_interleave] = !is_single_interleave\nparams_spiral[:do_odd_interleave] = false\nparams_spiral[:num_interleaves] = is_single_interleave ? 1 : length(params_spiral[:interleave_data_filenames]) # one interleaf per file, count files, if filenames are array of strings (not only one string)\nparams_spiral[:single_slice] = !is_multislice","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"Here we synchronize the spiral k-space data with trajectory by upsampling the trajectory. Subsequently, data of all the selected spiral interleaves and the corresponding trajectories are merged into imaging_acq_data. This step is done through the function merge_raw_interleaves, which can be viewed in utils.jl.","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"Since the loaded/calculated sens maps and B₀ maps are in ascending slice order, they need to be reordered according to the slice order in the spiral RawAcqData.","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"We only do these steps when they have not been done yet or it's specifically required.","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"if reload_spiral_data || !(@isdefined imaging_acq_data) || !(@isdefined slice_idx_array_spiral)\n    @info \"Reading spiral data and merging interleaves\"\n    imaging_acq_data = merge_raw_interleaves(params_spiral, false)\n    raw_temp  = RawAcquisitionData(ISMRMRDFile(params_general[:scan_fullpath][1]))\n    slice_idx_array_spiral = get_slice_order(raw_temp, num_slices, (num_slices+1)*2, 2)\n    b0_maps = b0_maps[:, :, invperm(slice_idx_array_spiral)]\n    cartesian_sensitivity = cartesian_sensitivity[:, :, invperm(slice_idx_array_spiral), :]\nend","category":"page"},{"location":"generated/joss_demo/#.2.3-Correction-of-k-space-Trajectory-Using-Gradient-Impulse-Response-Function","page":"GIRFReco.jl Example Script","title":"3.2.3 Correction of k-space Trajectory Using Gradient Impulse Response Function","text":"","category":"section"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"The previously calculated GIRFs are loaded.","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"The spiral trajectory is corrected by the 1st and 0th order of GIRF.","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"#Correct trajectory with the first order GIRFs (K1)\ngirf_k1 = readGIRFFile(params_general[:girf_fullpath][1], params_general[:girf_fullpath][2], params_general[:girf_fullpath][3], \"GIRF_FT\", false)\ngirf_applier_k1 = GirfApplier(girf_k1, params_general[:gamma])\n\n#Correct trajectory with the zeroth order GIRFs (K0)\ngirf_k0 = readGIRFFile(params_general[:girf_fullpath][1], params_general[:girf_fullpath][2], params_general[:girf_fullpath][3], \"b0ec_FT\", true)\ngirf_applier_k0 = GirfApplier(girf_k0, params_general[:gamma])\n\nif params_general[:do_correct_with_girf_k1]\n    @info \"Correcting For GIRF\"\n    apply_girf!(imaging_acq_data, girf_applier_k1)\nend\n\nif params_general[:do_correct_with_girf_k0]\n    @info \"Correcting For k₀\"\n    apply_k0!(imaging_acq_data, girf_applier_k0)\nend","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"Check if the k-space trajectory is normalized to the range [-0.5, 0.5].","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"check_acquisition_nodes!(imaging_acq_data)","category":"page"},{"location":"generated/joss_demo/#.2.4-Center-the-Object-to-the-Field-of-View-(FOV)","page":"GIRFReco.jl Example Script","title":"3.2.4 Center the Object to the Field-of-View (FOV)","text":"","category":"section"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"If the scanned object is not in the center of the FOV, we need to shift FOV to place the object in the center. This is achieved through adding linear phases on all dimensions.","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"shift_kspace!(imaging_acq_data, params_general[:fov_shift])","category":"page"},{"location":"generated/joss_demo/#.2.5-Processing-Coil-Sensitivity-Maps","page":"GIRFReco.jl Example Script","title":"3.2.5 Processing Coil Sensitivity Maps","text":"","category":"section"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"We need to preprocess the coil sensitivity maps before reconstruction. This includes resizing the coil maps to the size of output encoding matrix size; compress the channels according to user's setting to achieve a faster reconstruction.","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"sensitivity = mapslices(x -> imresize(x, params_spiral[:recon_size][1], params_spiral[:recon_size][2]), cartesian_sensitivity, dims = [1, 2])","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"Optional: Plot the sensitivity maps of each coil on a given slice.","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"if params_general[:do_plot_recon]\n    plotlyjs()\n    plot_sense_maps(sensitivity, 20)\nend","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"Optional: Coil compression to further reduce the time of recon","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"if params_general[:do_coil_compression]\n    imaging_acq_data, ccMat_vec = softwareCoilCompression(imaging_acq_data, params_general[:num_virtual_coils])\n    sensitivity = applyCoilCompressionSensitivityMaps(sensitivity, ccMat_vec)\nend","category":"page"},{"location":"generated/joss_demo/#.2.6-Processing-Off-Resonance-(B)-Maps","page":"GIRFReco.jl Example Script","title":"3.2.6 Processing Off-Resonance (B₀) Maps","text":"","category":"section"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"We need to resize the B₀ maps to the size of output encoding matrix size.","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"resized_b0_maps = mapslices(x -> imresize(x, params_spiral[:recon_size][1], params_spiral[:recon_size][2]), b0_maps, dims = [1, 2])","category":"page"},{"location":"generated/joss_demo/#.2.7-Alignment-of-Off-Resonance,-Sensitivity,-and-Spiral-Data","page":"GIRFReco.jl Example Script","title":"3.2.7 Alignment of Off-Resonance, Sensitivity, and Spiral Data","text":"","category":"section"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"We need to make sure that the axes line up so we rotate the sensitivities and the off-resonance maps.","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"Depending on your geometry, this might not be necessary but in case you need them:","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"resized_b0_maps = mapslices(x->rotl90(x),resized_b0_maps,dims=[1,2])\nsensitivity = mapslices(x->rotl90(x),sensitivity,dims=[1,2])","category":"page"},{"location":"generated/joss_demo/#.3-Spiral-Image-Reconstruction","page":"GIRFReco.jl Example Script","title":"3.3 Spiral Image Reconstruction","text":"","category":"section"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"Here we start the spiral image reconstruction.","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"First we need to set necessary parameters for reconstruction, including iterative solver's setting, coil maps, B₀ maps, etc. These parameters are held under the dictionary params_recon.","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"Note that it is safer to cast B₀ maps to ComplexF32 if the current version of MRIReco.jl is used.","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"@info \"Setting Reconstruction Parameters\"\nparams_recon = Dict{Symbol,Any}()\nparams_recon[:reco] = \"multiCoil\"\nparams_recon[:reconSize] = params_spiral[:recon_size][1:2] # cannot avoid camel-case here since it is defined by MRIReco.jl and RegularizedLeastSquares.jl\nparams_recon[:regularization] = \"L2\"\nparams_recon[:λ] = 1e-3\nparams_recon[:iterations] = params_general[:num_recon_iterations]\nparams_recon[:solver] = \"cgnr\"\nparams_recon[:solverInfo] = SolverInfo(ComplexF32, store_solutions = false)\nparams_recon[:senseMaps] = ComplexF32.(sensitivity[:, :, selected_slice, :]) # cannot avoid camel-case here since it is defined by MRIReco.jl and RegularizedLeastSquares.jl\n\nif params_general[:do_correct_with_b0_map]\n    params_recon[:correctionMap] = ComplexF32.(-1im .* resized_b0_maps[:, :, selected_slice]) # cannot avoid camel-case here since it is defined by MRIReco.jl and RegularizedLeastSquares.jl\nend\n\n#=\nFinally we can call reconstruction function of the package `MRIReco.jl`\nto perform final spiral image reconstruction.\n=#\n@info \"Performing Spiral Reconstruction\"\n@time reco = reconstruction(imaging_acq_data, params_recon)\n\nGC.gc() # Recommended to force triger garbage collection especially when encountering memory issues.","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"Reorder slices of the reconstructed images to an ascending order","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"reco = reco[:,:,slice_idx_array_spiral[selected_slice]]\nresized_b0_maps = resized_b0_maps[:, :, slice_idx_array_spiral[selected_slice]]","category":"page"},{"location":"generated/joss_demo/#.-Save-and-Plot-the-Results-(Optional)","page":"GIRFReco.jl Example Script","title":"4. Save and Plot the Results (Optional)","text":"","category":"section"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"All results could be saved into NIfTI files using the save_map function and be plotted using the plot_reconstruction function, both located in the file utils.jl.","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"if params_general[:do_save_recon]\n    resolution_tmp = fieldOfView(imaging_acq_data)[1:2] ./ encodingSize(imaging_acq_data)\n    resolution_mm = (resolution_tmp[1], resolution_tmp[2], fieldOfView(imaging_acq_data)[3] * (1 + params_general[:slice_distance_factor_percent] / 100.0)) #for 2D only, since FOV[3] is slice thickness then, but gap has to be observed\n    num_slices = numSlices(imaging_acq_data)\n    save_map(\n        params_general[:recon_save_fullpath],\n        params_general[:saving_scalefactor] * reco.data[:, :, slice_idx_array_spiral],\n        resolution_mm;\n        do_split_phase = true,\n        do_normalize = params_general[:do_normalize_recon],\n    )\nend\n\nif params_general[:do_plot_recon]\n    @info \"Plotting Reconstruction\"\n    plotlyjs()\n    plot_reconstruction(\n        reco,\n        1:length(selected_slice),\n        resized_b0_maps,\n        is_slice_interleaved = false,\n        rotation = 90,\n    )\nend\n\n@info \"Successfully Completed Spiral Recon\"","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"","category":"page"},{"location":"generated/joss_demo/","page":"GIRFReco.jl Example Script","title":"GIRFReco.jl Example Script","text":"This page was generated using Literate.jl.","category":"page"},{"location":"Utilities/","page":"API","title":"API","text":"Modules = [GIRFReco]\nPages   = [\"utils.jl\", \"gradient_reader.jl\", \"fieldmap_estimator.jl\"]","category":"page"},{"location":"Utilities/#GIRFReco.adjust_header!-NTuple{5, Any}","page":"API","title":"GIRFReco.adjust_header!","text":"adjust_header!(raw::RawAcquisitionData, recon_size, num_samples, interleave_number, single_slice)\n\nAdjusts the header data for each interleave and slice of spiral diffusion RawAcquisitionData\n\nArguments\n\nraw::RawAcquisitionData - RawAcquisitionData object\nrecon_size::Vector - Reconstruction matrix size\nnum_samples::Int - Number of samples per interleave\ninterleave_number::Int - Index of interleave for multi-shot acquisitionNumbers\nsingle_slice::Bool - flag for single-slice reconstruction/acquisition\n\n\n\n\n\n","category":"method"},{"location":"Utilities/#GIRFReco.apply_girf!-Union{Tuple{T}, Tuple{MRIBase.AcquisitionData{T}, MRIGradients.GirfApplier}} where T","page":"API","title":"GIRFReco.apply_girf!","text":"apply_girf!(a::AcquisitionData{T}, g::GirfApplier)\n\nApplies the GIRF to the trajectories inside of a::AcquisitionData\n\nArguments\n\na::AcquisitionData{T}          - AcquisitionData object\ng::GirfApplier                 - GirfApplier object containing GIRF definition\n\n\n\n\n\n","category":"method"},{"location":"Utilities/#GIRFReco.apply_k0!-Union{Tuple{T}, Tuple{MRIBase.AcquisitionData{T}, MRIGradients.GirfApplier}} where T","page":"API","title":"GIRFReco.apply_k0!","text":"apply_k0!(a::AcquisitionData{T}, g::GirfApplier)\n\nApplies the K0 modulation due to imaging gradients to the data inside of a::AcquisitionData\n\nArguments\n\na::AcquisitionData{T}          - AcquisitionData object\ng::GirfApplier                 - GirfApplier containing GIRF definition\n\n\n\n\n\n","category":"method"},{"location":"Utilities/#GIRFReco.calculate_b0_maps-NTuple{4, Any}","page":"API","title":"GIRFReco.calculate_b0_maps","text":"calculate_b0_maps(me_data, slices, echotime_1, echotime_2)\n\nCalculate B₀ map from the two images with different echo times via their phase difference (phase of imgTE2.*conj(imgTE1))\n\nArguments\n\nme_data                          - [nX nY nZ 2 num_coils] 5D image array, 4th dim is echo time\nslices::NTuple{num_slices,Int}   - slice index vector (tuple?) for which map is computed\nechotime_1::AbstractFloat        - TE1 [ms]\nechotime_2::AbstractFloat        - TE2 [ms]\n\n\n\n\n\n","category":"method"},{"location":"Utilities/#GIRFReco.check_acquisition_nodes!-Tuple{MRIBase.AcquisitionData}","page":"API","title":"GIRFReco.check_acquisition_nodes!","text":"check_acquisition_nodes!(a::AcquisitionData)\n\nValidates processed AcquisitionData object to make sure that |kᵢ| < 0.5 ∀ i ∈ [1, Nₛ]\n\nArguments\n\na::AcquisitionData - AcquisitionData object\n\n\n\n\n\n","category":"method"},{"location":"Utilities/#GIRFReco.check_profiles-Tuple{Any}","page":"API","title":"GIRFReco.check_profiles","text":"check_profiles(raw_data::RawAcquisitionData)\n\nSanity check of RawAcqData object by ploting all profiles to confirm its consistency with ISMRMRD file\n\nArguments\n\nraw_data::RawAcquisitionData - RawAcquisitionData object\nnum_profiles_display - The number of profiles to be displayed\n\n\n\n\n\n","category":"method"},{"location":"Utilities/#GIRFReco.do_k0_correction!-Tuple{Any, Any, Any}","page":"API","title":"GIRFReco.do_k0_correction!","text":"do_k0_correction!(raw_data, k0_phase_modulation, interleave)\n\nApplies phase modulation due to 0th-order field fluctuations during the acquisition\n\nArguments\n\nraw_data::RawAcquisitionData - RawAcquisitionData object\nk0_phase_modulation::Matrix{Complex{T}} - Vector containing phase modulation measurements\ninterleave::Int - index of interleave\n\n\n\n\n\n","category":"method"},{"location":"Utilities/#GIRFReco.get_slice_order-Tuple{MRIBase.RawAcquisitionData, Int64, Int64, Int64}","page":"API","title":"GIRFReco.get_slice_order","text":"get_slice_order(r::RawAcquisitionData, sliceNum::Int, startProfile::Int, incProfile:Int)\n\nReturn a array of slice order index with ascending order of Z position.\n\ne.g. For an interleaved pattern of slice position in RawAcquisitionData given below (in unit of mm): [-7, -3, 1, 5, 9, -9, -5, -1, 3, 7], the output will be [6, 1, 7, 2, 8, 3, 9, 4, 10, 5]\n\nArguments\n\nr::RawAcquisitionData       - A RawAcquisitionData that directly reads from original MRD file\nsliceNum::Int               - Total slice number that included in the RawAcquisitionData\nstartProfile::Int           - Starting index of the profile in the RawAcqData for the first valid slice to be processed\nincProfile::Int             - Increment of profile index for the next valid slices\n\nOutput\n\norderedIndex                    - array with slice index of RawAcquisitionData with ascending order of position in Z.\n\n\n\n\n\n","category":"method"},{"location":"Utilities/#GIRFReco.load_map-Tuple{Any}","page":"API","title":"GIRFReco.load_map","text":"load_map(filename; do_split_phase::Bool = false)\n\nLoad calibration maps (sensitivity or B₀) from 4D NIfTI file(s)\n\nFor complex-valued data, magnitude and phase parts are stored in two files with suffix \"magn\" and \"phase\".\n\nArguments\n\nfilename::String            - string filename with extension .nii, example \"sensemap.nii\"\ndo_split_phase::Bool=false    - if true, data is saved in two nifti files with suffix \"magn\" and \"phase\", respectively                                 to enable display in typical NIfTI viewers\n\nOutput\n\ncalib_map                    - [nX nY nZ {nChannels}] 4-D sensitivity or 3D B₀ map array \n\n\n\n\n\n","category":"method"},{"location":"Utilities/#GIRFReco.merge_raw_interleaves-Tuple{Any, Any}","page":"API","title":"GIRFReco.merge_raw_interleaves","text":"merge_raw_interleaves(params, output_raw)\n\nMerges multiple interleave data together from individually acquired interleave scans\n\nArguments\n\nparams          - Dictionary\noutput_raw      - Bool\n\n\n\n\n\n","category":"method"},{"location":"Utilities/#GIRFReco.plot_reconstruction-Tuple{Any, Any, Any}","page":"API","title":"GIRFReco.plot_reconstruction","text":"plot_reconstruction(images, slices_index, b0; is_slice_interleaved = false, rotation = 0)\n\nPlots the magnitude and phase of the reconstructed images for a given slice or slices, along with a B₀ map if applicable\n\nArguments\n\nimages - Complex-valued images reconstructed using MRIReco.jl\nslices_index::Vector{Int} - slices to plot\nb0 - off-resonance map to plot along with images\nis_slice_interleaved::Bool - for 2D scanning, indicate this value as true to make sure the slice order on the displayed results is correct\nrotation::Int - Counterclock-wise rotation angle for each slice, should be a value from 0, 90, 180, 270 degrees\n\n\n\n\n\n","category":"method"},{"location":"Utilities/#GIRFReco.plot_sense_maps-Tuple{Any, Any}","page":"API","title":"GIRFReco.plot_sense_maps","text":"plot_sense_maps(sensitivity, num_channels; slice_index = 1)\n\nPlots coil sensitivity maps from the channels, for a given number of num_channels plots on a given slice index.\n\nArguments\n\nsensitivity - sensitivity maps, a 4D array: [nX, nY, nZ, nCoil]\nnum_channels - number of coils to be displayed.\nslice_index - The index of the slice to be displayed (if multislice)\n\n\n\n\n\n","category":"method"},{"location":"Utilities/#GIRFReco.preprocess_cartesian_data-Tuple{MRIBase.RawAcquisitionData, Any}","page":"API","title":"GIRFReco.preprocess_cartesian_data","text":"preprocess_cartesian_data(r::RawAcquisitionData, do_save; filename = \"data/processed_cartesian_file.h5\")\n\nPrepares Cartesian for reconstruction\n\nArguments\n\nr::RawAcquisitionData{T}   - RawAcquisitionData object\ndo_save::Boolean           - Save the processed Cartesian data as a HDF5 file\nfilename                   - filename to save the preprocessed data\n\n\n\n\n\n","category":"method"},{"location":"Utilities/#GIRFReco.remove_oversampling!-Tuple{MRIBase.RawAcquisitionData}","page":"API","title":"GIRFReco.remove_oversampling!","text":"remove_oversampling!(raw::RawAcquisitionData)\n\nRemoves 2x readout oversampling in raw data along read-out dimension.\n\nArguments\n\nraw::RawAcquisitionData{T}          - RawAcquisitionData object\n\n\n\n\n\n","category":"method"},{"location":"Utilities/#GIRFReco.save_map-Tuple{Any, Any, Any}","page":"API","title":"GIRFReco.save_map","text":"save_map(filename, calib_map, resolution_mm; offset_mm = [0.0, 0.0, 0.0], do_split_phase::Bool = false, do_normalize::Bool = true)\n\nSaves calibration maps (sensitivity or B₀) as 4D NIfTI file(s)\n\nFor complex-valued data, magnitude and phase can be split into separate files\n\nArguments\n\nfilename::String              - string filename with extension .nii, example \"sensemap.nii\"\ncalib_map                     - [nX nY nZ {nChannels}] 4-D sensitivity or 3D B₀ map array \nresolution_mm                 - resolution in mm, 3 element vector, e.g., [1.0, 1.0, 2.0]\noffset_mm                     - isocenter offset in mm, default: [0.0, 0.0, 0.0]\ndo_split_phase::Bool = false  - if true, data is saved in two nifti files with suffix \"magn\" and \"phase\", respectively                                 to enable display in typical NIfTI viewers\ndo_normalize::Bool = true     - if true, normalize the image by its magnitude maxima\n\n\n\n\n\n","category":"method"},{"location":"Utilities/#GIRFReco.shift_kspace!-Tuple{Any, Any}","page":"API","title":"GIRFReco.shift_kspace!","text":"shift_kspace!(acqdata, shift)\n\nThis function applys additional phase ramps to k-space data to achive a given shift of center of image FOV in X and Y directions.\n\nPerhaps this should be called shiftfov; however, since this function is modifying kspace data, it is named shiftkspace for now.\n\nArguments\n\nacqdata::AcquisitionData{T}     - AcquisitionData object to be modified\nshift::AbstractVector           - Vector containing shift with size [shiftX, shiftY]\n\n\n\n\n\n","category":"method"},{"location":"Utilities/#GIRFReco.sync_traj_and_data!-NTuple{4, Any}","page":"API","title":"GIRFReco.sync_traj_and_data!","text":"sync_traj_and_data!(a::AcquisitionData)\n\nSynchronizes k-space trajectory and sampled data as they do not usually have a common sampling rate\n\nArguments\n\nraw_data::RawAcquisitionData - RawAcquisitionData object\ntraj::Trajectory - Trajectory object to be synchronized with data contained in raw_data\nidx_crop::Int - Trajectory and Data may contain samples we don't want in the recon, usually at the end of acquisition. Ignore samples after idx_crop\ninterleave::Int - index of interleave\n\n\n\n\n\n","category":"method"},{"location":"Utilities/#GIRFReco.validate_acq_data!-Tuple{MRIBase.AcquisitionData}","page":"API","title":"GIRFReco.validate_acq_data!","text":"validate_acq_data!(a::AcquisitionData)\n\nValidates processed AcquisitionData object after manipulation, etc...\n\nArguments\n\na::AcquisitionData - AcquisitionData object\n\n\n\n\n\n","category":"method"},{"location":"Utilities/#GIRFReco.validate_siemens_mrd!-Tuple{MRIBase.RawAcquisitionData}","page":"API","title":"GIRFReco.validate_siemens_mrd!","text":"validate_siemens_mrd!(r::RawAcquisitionData)\n\nValidates RawAcquisitionData object created from ISMRMRD format object\n\nArguments\n\nr::RawAcquisitionData - RawAcquisitionData object\n\n\n\n\n\n","category":"method"},{"location":"Utilities/#GIRFReco.read_gradient_text_file-Tuple{Any, Any, Any}","page":"API","title":"GIRFReco.read_gradient_text_file","text":"read_gradient_text_file(filename, reconsize, delay)\n\nReads in text file containing gradient waveform information\n\nArguments\n\nfilename - filename (with full path) of text file with gradient waveform information\nreconsize::Tuple{Int64,Int64,Int64} - size of reconstructed image (trailing dimension 1 for 2D acquisitions)\ndelay - delay in seconds from the nominal first sampling point to the actual first sampling point\n\n\n\n\n\n","category":"method"},{"location":"Utilities/#GIRFReco.R-Union{Tuple{Matrix{T}}, Tuple{T}} where T","page":"API","title":"GIRFReco.R","text":"R(x::Matrix{T}) Regularization function which penalizes roughness\n\nArguments\n\nx::Matrix{T} - fieldmap estimate (in radians)\n\n\n\n\n\n","category":"method"},{"location":"Utilities/#GIRFReco.estimate_b0_maps","page":"API","title":"GIRFReco.estimate_b0_maps","text":"estimateb0maps(im_data,slices, TE1,TE2,β,isrotated) Processes 3D volume data as output from MRIReco.reconstruction to estimate fieldmaps using the method presented by Funai and Fessler\n\nRequired Arguments\n\nim_data - 5-D array with complex image data -> first \nslices - vector of slices to process (must be within range of 3rd dimension of im_data)\nTE1 - Echo time 1 [ms]\nTE2 - Echo time 2 [ms]\n\nOptional Arguments\n\nisrotated - Boolean controlling whether to rotate the B0 maps to match the images or not (legacy feature)\n\nKeyword Arguments\n\nβ - Regularization parameter controlling roughness penalty (larger = smoother)\nreltol - early stopping criteria (exit if subsequent cost function change < reltol)\n\n\n\n\n\n","category":"function"},{"location":"Utilities/#GIRFReco.ml_cost-Union{Tuple{T}, Tuple{Matrix{T}, Array{Complex{T}, 2}, Array{Complex{T}, 2}, Matrix{T}, Any}} where T","page":"API","title":"GIRFReco.ml_cost","text":"ml_cost(x::Matrix{T},y::Matrix{Complex{T}},z::Matrix{Complex{T}}, β) Calculates the ML estimator cost between an estimated phase map and the underlying multi-echo scan data\n\nArguments\n\nx::Matrix{T} - fieldmap estimate (in radians)\ny::Matrix{Complex{T}} - Complex first-echo image data\nz::Matrix{Complex{T}} - Complex second-echo image data\nm::Matrix{T} - normalized weighting data (m ∈ [0,1]:= abs.(conj.(y).z)./maximum(abs.(conj.(y).z))), precomputed for speed\nβ - Regularization parameter controlling roughness penalty\n\n\n\n\n\n","category":"method"},{"location":"Utilities/#GIRFReco.pcg_ml_est_fieldmap-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}, 2}, AbstractArray{Complex{T}, 2}}, Tuple{AbstractArray{Complex{T}, 2}, AbstractArray{Complex{T}, 2}, Any}, Tuple{AbstractArray{Complex{T}, 2}, AbstractArray{Complex{T}, 2}, Any, Any}} where T","page":"API","title":"GIRFReco.pcg_ml_est_fieldmap","text":"pcgmlest_fieldmap(y::AbstractMatrix{Complex{T}},z::AbstractMatrix{Complex{T}},β)  Estimates the fieldmap using the method presented in https://doi.org/10.1109/tmi.2008.923956\n\nRequired Arguments\n\ny::AbstractMatrix{Complex{T}} - Complex first-echo image data\nz::AbstractMatrix{Complex{T}} - Complex second-echo image data\n\nOptional Arguments\n\nβ - Regularization parameter controlling roughness penalty\nreltol - early stopping criteria (exit if subsequent cost function change < reltol)\n\n\n\n\n\n","category":"method"},{"location":"generated/recon_config_joss_demo/","page":"GIRFReco.jl Example Configuration","title":"GIRFReco.jl Example Configuration","text":"EditURL = \"../../lit/examples/recon_config_joss_demo.jl\"","category":"page"},{"location":"generated/recon_config_joss_demo/#example_config","page":"GIRFReco.jl Example Configuration","title":"GIRFReco.jl Example Configuration","text":"","category":"section"},{"location":"generated/recon_config_joss_demo/#Introduction","page":"GIRFReco.jl Example Configuration","title":"Introduction","text":"","category":"section"},{"location":"generated/recon_config_joss_demo/","page":"GIRFReco.jl Example Configuration","title":"GIRFReco.jl Example Configuration","text":"This recon_config.jl file describes all general reconstruction parameters, as well as data locations and selections for an iterative non-Cartesian reconstruction that relies on an external reference scan (Cartesian) to estimate calibration maps (coil sensitivities, B₀ maps).","category":"page"},{"location":"generated/recon_config_joss_demo/","page":"GIRFReco.jl Example Configuration","title":"GIRFReco.jl Example Configuration","text":"All parameters are stored in a dictionary named params_general.","category":"page"},{"location":"generated/recon_config_joss_demo/","page":"GIRFReco.jl Example Configuration","title":"GIRFReco.jl Example Configuration","text":"params_general = Dict{Symbol,Any}();\nnothing #hide","category":"page"},{"location":"generated/recon_config_joss_demo/","page":"GIRFReco.jl Example Configuration","title":"GIRFReco.jl Example Configuration","text":"Gyromagnetic ratio, in unit of Hz","category":"page"},{"location":"generated/recon_config_joss_demo/","page":"GIRFReco.jl Example Configuration","title":"GIRFReco.jl Example Configuration","text":"params_general[:gamma] = 42577478;\nnothing #hide","category":"page"},{"location":"generated/recon_config_joss_demo/","page":"GIRFReco.jl Example Configuration","title":"GIRFReco.jl Example Configuration","text":"General options for reconstruction script:","category":"page"},{"location":"generated/recon_config_joss_demo/","page":"GIRFReco.jl Example Configuration","title":"GIRFReco.jl Example Configuration","text":"params_general[:do_load_maps] = true                 # if true, reloads B₀/SENSE maps instead of recalculating\nparams_general[:do_save_recon] = true                # if true, saves reconstruction and all auxiliary image data (maps) as NIfTI files\nparams_general[:do_plot_recon] = true                # if true, plots intermediate debugging and output recon figures (needs graphics, not recommended in multi-thread mode due to PyPlot)\nparams_general[:do_process_map_scan] = true          # if true, compute sensitivity and B₀ maps from reconstructed Cartesian scan\nparams_general[:do_save_processed_map_scan] = false  # save ISMRMD file of preprocessed Cartesian data (before recon)\nparams_general[:recon_id] = \"v7\"                     # unique identifier for the saved result files\nparams_general[:do_correct_with_b0_map] = true       # whether perform off-resonance correction\nparams_general[:do_correct_with_girf_k1] = true      # whether perform 1st order GIRF correction\nparams_general[:do_correct_with_girf_k0] = true      # whether perform 1st order GIRF correction\nparams_general[:do_coil_compression] = false         # whether perform coil compression\nparams_general[:do_normalize_recon] = false;         # if true, set the range of magnitude image as [0 1]\nnothing #hide","category":"page"},{"location":"generated/recon_config_joss_demo/","page":"GIRFReco.jl Example Configuration","title":"GIRFReco.jl Example Configuration","text":"General parameters for reconstruction:","category":"page"},{"location":"generated/recon_config_joss_demo/","page":"GIRFReco.jl Example Configuration","title":"GIRFReco.jl Example Configuration","text":"params_general[:num_adc_samples] = 15650             # total number of ADC points BEFORE the rewinder at the end of the spiral readout. Need to check with data. # 15504 for 523, 15655 for gradient 508\nparams_general[:recon_size] = [200, 200, 1]          # the matrix size of the reconstructed images. Needs to specify 1 on Z dimension for 2D images\nparams_general[:num_recon_iterations] = 40             # number of recon iterations (for both Cartesian and Spiral recon)\nparams_general[:b0_map_beta] = 0.1             # for estimate_b0_maps, * `β` - Regularization parameter controlling roughness penalty (larger = smoother, default 5e-4)\nparams_general[:saving_scalefactor] = 1.0e9    # typical range of recon intensities is 1e-7, rescale when saving, e.g., to 0...1000 roughly for fMRI analysis\nparams_general[:num_virtual_coils] = 8                 # if perform coil compression, the number of coils to be compressed to\nparams_general[:fov_shift] = [-2, -5]               # amount of FOV shift; in unit of number of voxels in [x,y] direction (for our in-vivo dataset this is [0, -15], change as necessary)\nparams_general[:slice_distance_factor_percent] = 400 # Scan parameters, Additional acquisition information, e.g., slice distance etc.\nparams_general[:num_total_diffusion_directions] = 6;          # Need to specify total diffusion directions included in the raw data\nnothing #hide","category":"page"},{"location":"generated/recon_config_joss_demo/#Data-selector","page":"GIRFReco.jl Example Configuration","title":"Data selector","text":"","category":"section"},{"location":"generated/recon_config_joss_demo/","page":"GIRFReco.jl Example Configuration","title":"GIRFReco.jl Example Configuration","text":"See details in the page Advanced Usage.","category":"page"},{"location":"generated/recon_config_joss_demo/","page":"GIRFReco.jl Example Configuration","title":"GIRFReco.jl Example Configuration","text":"Data selector is designed for calling the script repetitively through RunReconLoop.jl for e.g. different diffusion directions and/or different averages. Note that the index of diffusion direction starts from 0 (b=0) to the total number in MDDW protocol, e.g. for 6 diffusion directions, 1-6 stands for 6 DWIs. boolean is_called_from_global_recon should be set as true if this RunReconLoop.jl is active. If iscalledfromglobalrecon is false or not defined, the data selector needs to be defined in the following code block.","category":"page"},{"location":"generated/recon_config_joss_demo/","page":"GIRFReco.jl Example Configuration","title":"GIRFReco.jl Example Configuration","text":"if !(@isdefined is_called_from_global_recon) || !is_called_from_global_recon\n    global selector = Dict{Symbol,Any}()\n    selector[:avg] = 1\n    selector[:seg] = 1\n    selector[:dif] = 0;\nend","category":"page"},{"location":"generated/recon_config_joss_demo/#Directories-and-File-Names","page":"GIRFReco.jl Example Configuration","title":"Directories and File Names","text":"","category":"section"},{"location":"generated/recon_config_joss_demo/","page":"GIRFReco.jl Example Configuration","title":"GIRFReco.jl Example Configuration","text":"We set directories for data reading in and results writing in this section.","category":"page"},{"location":"generated/recon_config_joss_demo/#Specifying-Directories","page":"GIRFReco.jl Example Configuration","title":"Specifying Directories","text":"","category":"section"},{"location":"generated/recon_config_joss_demo/","page":"GIRFReco.jl Example Configuration","title":"GIRFReco.jl Example Configuration","text":"params_general[:project_path] = root_project_path # Root path for the project\n\n#Path to ISMRMRD files (raw k-space data) [Input]\nparams_general[:data_path] = params_general[:project_path]\n#Path to spiral readout gradient files [Input]\nparams_general[:gradients_path] = joinpath(params_general[:project_path], \"Gradients\")\n#Path to GIRF files [Input]\nparams_general[:girf_path] = joinpath(params_general[:project_path], \"GIRF\", \"GIRF_ISMRM2022\")\n#Path to middle results (coil and B₀ maps) files [Output]\nparams_general[:results_path] = joinpath(params_general[:project_path], \"results\", \"phantom\")\n#Path to final reconstructed spiral images [Output]\nparams_general[:recon_save_path] = joinpath(params_general[:results_path], \"recon\", params_general[:recon_id]);\nnothing #hide","category":"page"},{"location":"generated/recon_config_joss_demo/#Specifying-File-Names","page":"GIRFReco.jl Example Configuration","title":"Specifying File Names","text":"","category":"section"},{"location":"generated/recon_config_joss_demo/","page":"GIRFReco.jl Example Configuration","title":"GIRFReco.jl Example Configuration","text":"params_general[:map_scan_filename] = \"Fieldmaps/meas_MID00083_FID06181_GRE_FieldMap_DualEcho_2mm.mrd\" # Cartesian dual-echo file, for coil and B₀ maps calculation [Input]\nparams_general[:map_scan_filename_stem] = \"meas_MID00083_FID06181_GRE_FieldMap_DualEcho_2mm.mrd\"\nparams_general[:girf_filename] = [\"2021Nov_PosNeg_Gx.mat\", \"2021Nov_PosNeg_Gy.mat\", \"2021Nov_PosNeg_Gz.mat\"] # Calculated GIRF for each gradient axis [Input]\nparams_general[:gradient_filename] = joinpath(\"gradients508.txt\"); # File name for the spiral gradient [Input]\nnothing #hide","category":"page"},{"location":"generated/recon_config_joss_demo/","page":"GIRFReco.jl Example Configuration","title":"GIRFReco.jl Example Configuration","text":"Select here if you want to use the first spiral interleave or all 4 interleaves for reconstruction. We are selecting the first interleave as demo. If you want a multi-interleave spiral reconstruction, remove the comment mark on the 2nd line.","category":"page"},{"location":"generated/recon_config_joss_demo/","page":"GIRFReco.jl Example Configuration","title":"GIRFReco.jl Example Configuration","text":"params_general[:scan_filename] = [\"Spirals/meas_MID00072_FID06170_diffSpiral_508_Intl0_b2k_4Avg.mrd\"] # ISMRMRD Raw k-space data for spiral acquisition [Input]\n#params_general[:scan_filename] = [\"Spirals/meas_MID00072_FID06170_diffSpiral_508_Intl0_b2k_4Avg.mrd\",\"Spirals/meas_MID00074_FID06172_diffSpiral_508_Intl1_b2k_4Avg.mrd\",\"Spirals/meas_MID00076_FID06174_diffSpiral_508_Intl2_b2k_4Avg.mrd\",\"Spirals/meas_MID00078_FID06176_diffSpiral_508_Intl3_b2k_4Avg.mrd\"]\n\nparams_general[:scan_filename_stem] = \"meas_MID00072_FID06170_diffSpiral_508_Intl0_b2k_4Avg.mrd\" # Main file name when saving the result\nparams_general[:processed_map_scan_filename] = \"processed_cartesian_data.h5\" # file name for preprocessed data (remove oversampling, permute dimensions wrt MRIReco) [Output]\nparams_general[:map_save_filename] = splitext(params_general[:map_scan_filename_stem])[1] * \"_reconmap.nii\" # File name for reconstructed dual-echo Cartesian images [Output]\nparams_general[:sensitivity_save_filename] = splitext(params_general[:map_scan_filename_stem])[1] * \"_sensemap.nii\" # File name for calculated coil sensitivity maps [Output]\nparams_general[:b0_map_save_filename] = splitext(params_general[:map_scan_filename_stem])[1] * \"_b0map.nii\"; # File name for calculated off-resonance (B₀) maps [Output]\nnothing #hide","category":"page"},{"location":"generated/recon_config_joss_demo/","page":"GIRFReco.jl Example Configuration","title":"GIRFReco.jl Example Configuration","text":"File name for the final reconstructed spiral image. If we reconstructing multiple spiral data files (e.g. multiple interleaves) through RunReconLoop.jl, the file name for the final reconstructed image is concatenated from multiple scan file names. Otherwise, just append _recon.nii as suffix to file name.","category":"page"},{"location":"generated/recon_config_joss_demo/","page":"GIRFReco.jl Example Configuration","title":"GIRFReco.jl Example Configuration","text":"if isa(params_general[:scan_filename], AbstractVector)\n    params_general[:recon_save_filename] =\n        join([(x[1] * \"_\") for x in splitext.(params_general[:scan_filename_stem])]) *\n        \"dif$(selector[:dif])_\" *\n        \"itl$(selector[:seg])_\" *\n        \"avg$(selector[:avg])_\" *\n        \"recon.nii\";\nelse\n    params_general[:recon_save_filename] = splitext(params_general[:scan_filename_stem])[1] * \"_recon.nii\";\nend","category":"page"},{"location":"generated/recon_config_joss_demo/#Assembling-Full-Paths","page":"GIRFReco.jl Example Configuration","title":"Assembling Full Paths","text":"","category":"section"},{"location":"generated/recon_config_joss_demo/","page":"GIRFReco.jl Example Configuration","title":"GIRFReco.jl Example Configuration","text":"Assembling directories and file names for final full pathes. These are automated operations.","category":"page"},{"location":"generated/recon_config_joss_demo/","page":"GIRFReco.jl Example Configuration","title":"GIRFReco.jl Example Configuration","text":"params_general[:gradient_fullpath] = joinpath(params_general[:gradients_path], params_general[:gradient_filename]) # Full paths of spiral readout gradients\nparams_general[:girf_fullpath] = joinpath.(params_general[:girf_path], params_general[:girf_filename]) # Full paths of GIRF files\nparams_general[:map_scan_fullpath] = joinpath(params_general[:data_path], params_general[:map_scan_filename]) # Full path of dual-echo Cartesian data\nparams_general[:scan_fullpath] = joinpath.(params_general[:data_path], params_general[:scan_filename]) # Full paths of raw k-space data files of spiral acquisition\nparams_general[:processed_map_scan_fullpath] = joinpath(params_general[:recon_save_path], params_general[:processed_map_scan_filename]) # Full paths of pre-processed Cartesian dual-echo data [Output]\nparams_general[:recon_save_fullpath] = joinpath(params_general[:recon_save_path], params_general[:recon_save_filename]) # Full paths of the reconstructed spiral image [Output]\nparams_general[:map_save_fullpath] = joinpath(params_general[:recon_save_path], params_general[:map_save_filename]) # Full paths of reconstructed dual-echo Cartesian images [Output]\nparams_general[:sensitivity_save_fullpath] = joinpath(params_general[:recon_save_path], params_general[:sensitivity_save_filename]) # Full paths of calculated coil sensitivity maps [Output]\nparams_general[:b0_map_save_fullpath] = joinpath(params_general[:recon_save_path], params_general[:b0_map_save_filename]); # Full paths of calculated off-resonance (B₀) maps [Output]\nnothing #hide","category":"page"},{"location":"generated/recon_config_joss_demo/#Final-Steps","page":"GIRFReco.jl Example Configuration","title":"Final Steps","text":"","category":"section"},{"location":"generated/recon_config_joss_demo/","page":"GIRFReco.jl Example Configuration","title":"GIRFReco.jl Example Configuration","text":"Optional: If the path for results writing is not existing, create it.","category":"page"},{"location":"generated/recon_config_joss_demo/","page":"GIRFReco.jl Example Configuration","title":"GIRFReco.jl Example Configuration","text":"As the last step of configuration, copy this config file to the recon path for further checking and debugging purposes.","category":"page"},{"location":"generated/recon_config_joss_demo/","page":"GIRFReco.jl Example Configuration","title":"GIRFReco.jl Example Configuration","text":"if ~ispath(params_general[:recon_save_path])\n    mkpath(params_general[:recon_save_path])\nend\n\ncp(@__FILE__, joinpath(params_general[:recon_save_path], \"recon_config.jl\"); force = true)","category":"page"},{"location":"generated/recon_config_joss_demo/","page":"GIRFReco.jl Example Configuration","title":"GIRFReco.jl Example Configuration","text":"","category":"page"},{"location":"generated/recon_config_joss_demo/","page":"GIRFReco.jl Example Configuration","title":"GIRFReco.jl Example Configuration","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#Welcome-to-the-GIRFReco.jl-Documentation","page":"Home","title":"Welcome to the GIRFReco.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GIRFReco.jl is an Open-Source End-to-End Pipeline for Spiral Magnetic Resonance Image (MRI) Reconstruction in Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"You may find the overview of this package as well as a quick-start in README","category":"page"},{"location":"","page":"Home","title":"Home","text":"This GIRFReco Documentation includes example scripts and technical documentation of functions/APIs. Please check the side bars for information about the provided functionality of the package. This documentation website automatically created by Documenter.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please report any bugs or feature requests under Issues.","category":"page"}]
}
