<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>GIRFReco.jl Example Script · GIRFReco.jl Documentation</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">GIRFReco.jl Documentation</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../Utilities/">API</a></li><li><span class="tocitem">Examples</span><ul><li class="is-active"><a class="tocitem" href>GIRFReco.jl Example Script</a><ul class="internal"><li><a class="tocitem" href="#.-Quick-Start"><span>0. Quick Start</span></a></li><li><a class="tocitem" href="#.-Setup"><span>1. Setup</span></a></li><li><a class="tocitem" href="#.-Configurations-for-reconstruction"><span>2. Configurations for reconstruction</span></a></li><li><a class="tocitem" href="#.-Image-Reconstruction"><span>3. Image Reconstruction</span></a></li><li><a class="tocitem" href="#.-Save-and-Plot-the-Results-(Optional)"><span>4. Save and Plot the Results (Optional)</span></a></li></ul></li><li><a class="tocitem" href="../recon_config_joss_demo/">GIRFReco.jl Example Configuration</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>GIRFReco.jl Example Script</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>GIRFReco.jl Example Script</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/BRAIN-TO/GIRFReco.jl/blob/main/docs/lit/examples/joss_demo.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="example_script"><a class="docs-heading-anchor" href="#example_script">GIRFReco.jl Example Script</a><a id="example_script-1"></a><a class="docs-heading-anchor-permalink" href="#example_script" title="Permalink"></a></h1><p>This page gives a step-by-step demonstration of an example script for using GIRFReco.jl, which consists of the following two files:</p><ul><li><p>A Julia script of an example pipeline for spiral reconstruction: <a href="https://github.com/BRAIN-TO/GIRFReco.jl/blob/main/example/joss_demo.jl"><code>joss_demo.jl</code></a></p></li><li><p>A configuration file which defines parameters for the spiral reconstruction: <a href="https://github.com/BRAIN-TO/GIRFReco.jl/blob/main/example/recon_config_joss_demo.jl"><code>recon_config_joss_demo.jl</code></a></p></li></ul><h2 id=".-Quick-Start"><a class="docs-heading-anchor" href="#.-Quick-Start">0. Quick Start</a><a id=".-Quick-Start-1"></a><a class="docs-heading-anchor-permalink" href="#.-Quick-Start" title="Permalink"></a></h2><p>To have a quick run of the example, simply take the following steps.</p><h3 id="(1)-Cloning-the-package"><a class="docs-heading-anchor" href="#(1)-Cloning-the-package">(1) Cloning the package</a><a id="(1)-Cloning-the-package-1"></a><a class="docs-heading-anchor-permalink" href="#(1)-Cloning-the-package" title="Permalink"></a></h3><p>Download or clone the repo to your local by:</p><pre><code class="nohighlight hljs">git clone git@github.com:BRAIN-TO/GIRFReco.jl.git</code></pre><p>Then enter the <code>example</code> folder:</p><pre><code class="nohighlight hljs">cd GIRFReco.jl/example</code></pre><p>Alternatively, for the one who are using Visual Studio Code, simply open the <code>example</code> sub-folder from the Menu option <code>File -&gt; Open Folder...</code>.</p><h3 id="(2)-Run-in-Julia-REPL"><a class="docs-heading-anchor" href="#(2)-Run-in-Julia-REPL">(2) Run in Julia REPL</a><a id="(2)-Run-in-Julia-REPL-1"></a><a class="docs-heading-anchor-permalink" href="#(2)-Run-in-Julia-REPL" title="Permalink"></a></h3><p>We recommend to use Visual Studio Code with Julia extension (steps of installation can be found <a href="https://code.visualstudio.com/docs/languages/julia">here</a>) to avoid possible image displaying issue, especially for those using SSH and X11 forwarding.</p><p>The Julia REPL can be launched from the Command Palette (For Windows and Linux: Press <code>Shift + Ctrl + P</code>; For Mac: Press <code>Shift + Command + P</code>) by searching the command <code>Julia: Start REPL</code>.</p><p>In the launched REPL, simpley execute the following command after launching REPL to run the whole demonstration script (including data download):</p><pre><code class="language-julia hljs">include(&quot;run_example.jl&quot;)</code></pre><p>If you only want to download the demonstration dataset, run:</p><pre><code class="language-julia hljs">include(&quot;download_data.jl&quot;)</code></pre><h3 id="(3)-After-your-first-example-running..."><a class="docs-heading-anchor" href="#(3)-After-your-first-example-running...">(3) After your first example running...</a><a id="(3)-After-your-first-example-running...-1"></a><a class="docs-heading-anchor-permalink" href="#(3)-After-your-first-example-running..." title="Permalink"></a></h3><p>&quot;Watch a movie, or be part of it&quot;. You are also encouraged to play around with the <a href="generated/[`recon_config_joss_demo.jl`](https:/github.com/BRAIN-TO/GIRFReco.jl/blob/main/example/recon_config_joss_demo.jl)">configuration file</a> and see how (and why) the results are changed. For example:</p><p>(1) How the results change when we turn off the B₀ correction (by setting <code>do_correct_with_b0_map</code> as <code>false</code>)?</p><p>(2) What will the images look like when we turn off the zeroth and/or the first order GIRF correction (set <code>do_correct_with_girf_k0</code> and/or <code>do_correct_with_girf_k1</code> as <code>false</code>)?</p><p>(3) Try reconstruction with multiple spiral interleaves by enabling line 97.</p><p>And so many more options to explore...</p><h2 id=".-Setup"><a class="docs-heading-anchor" href="#.-Setup">1. Setup</a><a id=".-Setup-1"></a><a class="docs-heading-anchor-permalink" href="#.-Setup" title="Permalink"></a></h2><p>The necessary Julia packages needed for spiral reconstruction.</p><pre><code class="language-julia hljs">#Our developed packages
using GIRFReco, MRIGradients

#MRIReco and its sub-packages
using MRIReco, FileIO, MRIFiles, MRIBase, MRICoilSensitivities

using RegularizedLeastSquares, Flux

using ImageTransformations

using PlotlyJS, Plots</code></pre><h2 id=".-Configurations-for-reconstruction"><a class="docs-heading-anchor" href="#.-Configurations-for-reconstruction">2. Configurations for reconstruction</a><a id=".-Configurations-for-reconstruction-1"></a><a class="docs-heading-anchor-permalink" href="#.-Configurations-for-reconstruction" title="Permalink"></a></h2><p>The following file, <a href="https://github.com/BRAIN-TO/GIRFReco.jl/blob/main/docs/lit/examples/recon_config_joss_demo.jl"><code>recon_config_joss_demo.jl</code></a>, includes general configuration for spiral reconstruction. It is necessary to execute this file to make sure all parameters are loaded. Sample Data that works with this script can be found <a href="https://doi.org/10.5281/zenodo.7779044">here</a>. Please download, extract and set the <code>root_project_path</code> as the top level folder (should be something like <code>/your/path/joss_data_zenodo/</code>)</p><pre><code class="language- hljs">root_project_path = &quot;/your/path/joss_data_zenodo/&quot; # Root path of the data extracted from Zenodo
include(&quot;recon_config_joss_demo.jl&quot;)

plotlyjs()</code></pre><p>Two parameters determining whether we want to reload the raw data of spiral and GIRF.</p><pre><code class="language-julia hljs">reload_spiral_data = true; # Set true if we need to reload raw data compulsively.
reload_girf_data = true; # Set true if we need to reload GIRF data compulsively.</code></pre><p>Choose Slice ([single number] OR [1, 2, 31, ...]） Leave an empty array ([]) or remove this line to select all slices</p><pre><code class="language-julia hljs">slice_choice = [];</code></pre><p>Choose which diffusion directions and averages to be processed. Diffusion direction index starts from 0 (b=0) to the total number in MDDW protocol (e.g. for 6 diffusion directions, 1-6 stands for 6 DWIs). Index for average starts from 1.</p><pre><code class="language- hljs">diffusion_direction = 0
idx_average = 1
num_total_diffusion_directions = params_general[:num_total_diffusion_directions]

# Determine to reconstruct single-interleave data, or one interleave out of multi-interleave data.
is_single_interleave = isa(params_general[:scan_fullpath], String)</code></pre><p>Choose which interleave to be reconstructed.</p><p>For multi-interleave data, the range of this value is [1:num_total_interleaves].</p><p>For single-interleave data, it should always be set as 1; for multi-interleave data, the value set here will be used, indicating which interleaves to be merged and reconstructed.</p><pre><code class="language-julia hljs">start_idx_interleave = 1;</code></pre><h2 id=".-Image-Reconstruction"><a class="docs-heading-anchor" href="#.-Image-Reconstruction">3. Image Reconstruction</a><a id=".-Image-Reconstruction-1"></a><a class="docs-heading-anchor-permalink" href="#.-Image-Reconstruction" title="Permalink"></a></h2><p>The steps of image reconstruction starts here.</p><h3 id=".1-Calculation-of-B-and-Coil-Sensitivity-Maps"><a class="docs-heading-anchor" href="#.1-Calculation-of-B-and-Coil-Sensitivity-Maps">3.1 Calculation of B₀ and Coil Sensitivity Maps</a><a id=".1-Calculation-of-B-and-Coil-Sensitivity-Maps-1"></a><a class="docs-heading-anchor-permalink" href="#.1-Calculation-of-B-and-Coil-Sensitivity-Maps" title="Permalink"></a></h3><p>The first step in reconstruction pipeline is to calculate the off-resonance (B₀) maps <code>b0_map</code> and coil sensitivity maps <code>cartesian_sensitivity</code> through the Cartesian reconstruction script <a href="https://github.com/BRAIN-TO/GIRFReco.jl/blob/main/recon/cartesian_recon.jl">cartesian_recon.jl</a>.</p><p>Ideally this script is execute once and the calculated maps are saved into files, which are loaded for future usage to save calculation time. This is controlled by <code>do_load_maps</code> in general parameters.</p><pre><code class="language- hljs">if params_general[:do_load_maps] &amp;&amp; isfile(params_general[:b0_map_save_fullpath])
    @info &quot;Loading SENSE and B₀ maps from $(params_general[:sensitivity_save_fullpath]) and $(params_general[:b0_map_save_fullpath])&quot;
    cartesian_sensitivity = load_map(params_general[:sensitivity_save_fullpath]; do_split_phase = true)
    b0_maps = load_map(params_general[:b0_map_save_fullpath])
    num_slices = size(b0_maps, 3)
else
    @info &quot;Running cartesian_recon to retrieve maps (cartesian_sensitivity and b0_maps)&quot;
    cartesian_sensitivity, b0_maps = run_cartesian_recon(params_general)
    num_slices = size(b0_maps, 3)
end</code></pre><h3 id=".2-Preparation-of-Spiral-Reconstruction"><a class="docs-heading-anchor" href="#.2-Preparation-of-Spiral-Reconstruction">3.2 Preparation of Spiral Reconstruction</a><a id=".2-Preparation-of-Spiral-Reconstruction-1"></a><a class="docs-heading-anchor-permalink" href="#.2-Preparation-of-Spiral-Reconstruction" title="Permalink"></a></h3><p>With off-resonance (B₀) maps and coil sensitivity maps calculated, before the reconstruction of spiral images, there are necessary steps to prepare for the related data.</p><h4 id=".2.1-Data-Selection"><a class="docs-heading-anchor" href="#.2.1-Data-Selection">3.2.1 Data Selection</a><a id=".2.1-Data-Selection-1"></a><a class="docs-heading-anchor-permalink" href="#.2.1-Data-Selection" title="Permalink"></a></h4><p>The first step is to select the part of spiral k-space data that we would like to reconstruct. This include selecting slices, diffusion directions, and averages that we want.</p><p>First we sort the slice index that we selected to reconstruct.</p><pre><code class="language- hljs">if isempty(slice_choice) || !(@isdefined slice_choice)
    slice_choice = collect(1:num_slices)
end

is_multislice = length(slice_choice) &gt; 1

if !is_multislice
    selected_slice = slice_choice
else
    selected_slice = sort(vec(slice_choice))
end</code></pre><p>Next we select the data we would like to reconstruct from the ISMRMRD file.</p><p>The ISMRMRD data are stored in the following loops:</p><p>Slice 1, Slice 2 ... Slice N   Slice 1, Slice 2 ... Slice N     Slice 1, Slice 2 ... Slice N ...</p><p>|______ Diff Dir 1 ______|   |______ Diff Dir 2 ______| ... |______ Diff Dir N ______| ...</p><p>|_________________________________ Average 1 ___________________________________| ... |___ Average N___|</p><p>Here we chose the set corresponding to the b-value = 0 images under the first average as the example.</p><p>Note that (1) The raw data file begins with a series of pre-scan profiles with a length of <code>num_slices*2</code> and we want to skip them; (2) There is a B1 measurement data profile between each k-space readout profile which also need to be skipped. Thus the reading of data profiles starts from <code>num_slices*2 + 2</code> with an increment of <code>2</code>.</p><pre><code class="language- hljs">excitation_list = collect(num_slices*2+2:2:num_slices*4) .+ diffusion_direction * num_slices * 2 .+ (idx_average - 1) * num_slices * (num_total_diffusion_directions + 1) * 2
slice_selection = excitation_list[selected_slice]</code></pre><h4 id=".2.2-Synchronizing-and-Merging-of-k-space-Data-and-Trajectory"><a class="docs-heading-anchor" href="#.2.2-Synchronizing-and-Merging-of-k-space-Data-and-Trajectory">3.2.2 Synchronizing and Merging of k-space Data and Trajectory</a><a id=".2.2-Synchronizing-and-Merging-of-k-space-Data-and-Trajectory-1"></a><a class="docs-heading-anchor-permalink" href="#.2.2-Synchronizing-and-Merging-of-k-space-Data-and-Trajectory" title="Permalink"></a></h4><p>Since the k-space data and spiral k-space trajectories are sampled under different sampling rates and stored in separate files, they need to be first synchronized into the frequency of k-space data and then merged into a single object before final spiral image reconstruction.</p><p>Here we use a dictionary <code>params_spiral</code> to hold the parameters for this k-space data/trajectory synchronization and merging.</p><pre><code class="language- hljs">params_spiral = Dict{Symbol,Any}()
params_spiral[:recon_size] = Tuple(params_general[:recon_size])
params_spiral[:interleave] = start_idx_interleave
params_spiral[:num_samples] = params_general[:num_adc_samples]
params_spiral[:delay] = 0.00000
params_spiral[:interleave_data_filenames] = params_general[:scan_fullpath]
params_spiral[:traj_filename] = params_general[:gradient_fullpath]
params_spiral[:excitations] = slice_selection
params_spiral[:do_multi_interleave] = !is_single_interleave
params_spiral[:do_odd_interleave] = false
params_spiral[:num_interleaves] = is_single_interleave ? 1 : length(params_spiral[:interleave_data_filenames]) # one interleaf per file, count files, if filenames are array of strings (not only one string)
params_spiral[:single_slice] = !is_multislice</code></pre><p>Here we synchronize the spiral k-space data with trajectory by upsampling the trajectory. Subsequently, data of all the selected spiral interleaves and the corresponding trajectories are merged into <code>imaging_acq_data</code>. This step is done through the function <code>merge_raw_interleaves</code>, which can be viewed in <a href="https://github.com/BRAIN-TO/GIRFReco.jl/blob/main/src/utils/utils.jl">utils.jl</a>.</p><p>Since the loaded/calculated sens maps and B₀ maps are in ascending slice order, they need to be reordered according to the slice order in the spiral RawAcqData.</p><p>We only do these steps when they have not been done yet or it&#39;s specifically required.</p><pre><code class="language- hljs">if reload_spiral_data || !(@isdefined imaging_acq_data) || !(@isdefined slice_idx_array_spiral)
    @info &quot;Reading spiral data and merging interleaves&quot;
    imaging_acq_data = merge_raw_interleaves(params_spiral, false)
    raw_temp  = RawAcquisitionData(ISMRMRDFile(params_general[:scan_fullpath][1]))
    slice_idx_array_spiral = get_slice_order(raw_temp, num_slices, (num_slices+1)*2, 2)
    b0_maps = b0_maps[:, :, invperm(slice_idx_array_spiral)]
    cartesian_sensitivity = cartesian_sensitivity[:, :, invperm(slice_idx_array_spiral), :]
end</code></pre><h4 id=".2.3-Correction-of-k-space-Trajectory-Using-Gradient-Impulse-Response-Function"><a class="docs-heading-anchor" href="#.2.3-Correction-of-k-space-Trajectory-Using-Gradient-Impulse-Response-Function">3.2.3 Correction of k-space Trajectory Using Gradient Impulse Response Function</a><a id=".2.3-Correction-of-k-space-Trajectory-Using-Gradient-Impulse-Response-Function-1"></a><a class="docs-heading-anchor-permalink" href="#.2.3-Correction-of-k-space-Trajectory-Using-Gradient-Impulse-Response-Function" title="Permalink"></a></h4><p>The previously calculated GIRFs are loaded.</p><p>The spiral trajectory is corrected by the 1st and 0th order of GIRF.</p><pre><code class="language- hljs">#Correct trajectory with the first order GIRFs (K1)
girf_k1 = readGIRFFile(params_general[:girf_fullpath][1], params_general[:girf_fullpath][2], params_general[:girf_fullpath][3], &quot;GIRF_FT&quot;, false)
girf_applier_k1 = GirfApplier(girf_k1, params_general[:gamma])

#Correct trajectory with the zeroth order GIRFs (K0)
girf_k0 = readGIRFFile(params_general[:girf_fullpath][1], params_general[:girf_fullpath][2], params_general[:girf_fullpath][3], &quot;b0ec_FT&quot;, true)
girf_applier_k0 = GirfApplier(girf_k0, params_general[:gamma])

if params_general[:do_correct_with_girf_k1]
    @info &quot;Correcting For GIRF&quot;
    apply_girf!(imaging_acq_data, girf_applier_k1)
end

if params_general[:do_correct_with_girf_k0]
    @info &quot;Correcting For k₀&quot;
    apply_k0!(imaging_acq_data, girf_applier_k0)
end</code></pre><p>Check if the k-space trajectory is normalized to the range <code>[-0.5, 0.5]</code>.</p><pre><code class="language- hljs">check_acquisition_nodes!(imaging_acq_data)</code></pre><h4 id=".2.4-Center-the-Object-to-the-Field-of-View-(FOV)"><a class="docs-heading-anchor" href="#.2.4-Center-the-Object-to-the-Field-of-View-(FOV)">3.2.4 Center the Object to the Field-of-View (FOV)</a><a id=".2.4-Center-the-Object-to-the-Field-of-View-(FOV)-1"></a><a class="docs-heading-anchor-permalink" href="#.2.4-Center-the-Object-to-the-Field-of-View-(FOV)" title="Permalink"></a></h4><p>If the scanned object is not in the center of the FOV, we need to shift FOV to place the object in the center. This is achieved through adding linear phases on all dimensions.</p><pre><code class="language- hljs">shift_kspace!(imaging_acq_data, params_general[:fov_shift])</code></pre><h4 id=".2.5-Processing-Coil-Sensitivity-Maps"><a class="docs-heading-anchor" href="#.2.5-Processing-Coil-Sensitivity-Maps">3.2.5 Processing Coil Sensitivity Maps</a><a id=".2.5-Processing-Coil-Sensitivity-Maps-1"></a><a class="docs-heading-anchor-permalink" href="#.2.5-Processing-Coil-Sensitivity-Maps" title="Permalink"></a></h4><p>We need to preprocess the coil sensitivity maps before reconstruction. This includes resizing the coil maps to the size of output encoding matrix size; compress the channels according to user&#39;s setting to achieve a faster reconstruction.</p><pre><code class="language- hljs">sensitivity = mapslices(x -&gt; imresize(x, params_spiral[:recon_size][1], params_spiral[:recon_size][2]), cartesian_sensitivity, dims = [1, 2])</code></pre><p>Optional: Plot the sensitivity maps of each coil on a given slice.</p><pre><code class="language- hljs">if params_general[:do_plot_recon]
    plotlyjs()
    plot_sense_maps(sensitivity, 20)
end</code></pre><p>Optional: Coil compression to further reduce the time of recon</p><pre><code class="language- hljs">if params_general[:do_coil_compression]
    imaging_acq_data, ccMat_vec = softwareCoilCompression(imaging_acq_data, params_general[:num_virtual_coils])
    sensitivity = applyCoilCompressionSensitivityMaps(sensitivity, ccMat_vec)
end</code></pre><h4 id=".2.6-Processing-Off-Resonance-(B)-Maps"><a class="docs-heading-anchor" href="#.2.6-Processing-Off-Resonance-(B)-Maps">3.2.6 Processing Off-Resonance (B₀) Maps</a><a id=".2.6-Processing-Off-Resonance-(B)-Maps-1"></a><a class="docs-heading-anchor-permalink" href="#.2.6-Processing-Off-Resonance-(B)-Maps" title="Permalink"></a></h4><p>We need to resize the B₀ maps to the size of output encoding matrix size.</p><pre><code class="language- hljs">resized_b0_maps = mapslices(x -&gt; imresize(x, params_spiral[:recon_size][1], params_spiral[:recon_size][2]), b0_maps, dims = [1, 2])</code></pre><h4 id=".2.7-Alignment-of-Off-Resonance,-Sensitivity,-and-Spiral-Data"><a class="docs-heading-anchor" href="#.2.7-Alignment-of-Off-Resonance,-Sensitivity,-and-Spiral-Data">3.2.7 Alignment of Off-Resonance, Sensitivity, and Spiral Data</a><a id=".2.7-Alignment-of-Off-Resonance,-Sensitivity,-and-Spiral-Data-1"></a><a class="docs-heading-anchor-permalink" href="#.2.7-Alignment-of-Off-Resonance,-Sensitivity,-and-Spiral-Data" title="Permalink"></a></h4><p>We need to make sure that the axes line up so we rotate the sensitivities and the off-resonance maps.</p><p>Depending on your geometry, this might not be necessary but in case you need them:</p><pre><code class="nohighlight hljs">resized_b0_maps = mapslices(x-&gt;rotl90(x),resized_b0_maps,dims=[1,2])
sensitivity = mapslices(x-&gt;rotl90(x),sensitivity,dims=[1,2])</code></pre><h3 id=".3-Spiral-Image-Reconstruction"><a class="docs-heading-anchor" href="#.3-Spiral-Image-Reconstruction">3.3 Spiral Image Reconstruction</a><a id=".3-Spiral-Image-Reconstruction-1"></a><a class="docs-heading-anchor-permalink" href="#.3-Spiral-Image-Reconstruction" title="Permalink"></a></h3><p>Here we start the spiral image reconstruction.</p><p>First we need to set necessary parameters for reconstruction, including iterative solver&#39;s setting, coil maps, B₀ maps, etc. These parameters are held under the dictionary <code>params_recon</code>.</p><p>Note that it is safer to cast B₀ maps to ComplexF32 if the current version of MRIReco.jl is used.</p><pre><code class="language- hljs">@info &quot;Setting Reconstruction Parameters&quot;
params_recon = Dict{Symbol,Any}()
params_recon[:reco] = &quot;multiCoil&quot;
params_recon[:reconSize] = params_spiral[:recon_size][1:2] # cannot avoid camel-case here since it is defined by MRIReco.jl and RegularizedLeastSquares.jl
params_recon[:regularization] = &quot;L2&quot;
params_recon[:λ] = 1e-3
params_recon[:iterations] = params_general[:num_recon_iterations]
params_recon[:solver] = &quot;cgnr&quot;
params_recon[:solverInfo] = SolverInfo(ComplexF32, store_solutions = false)
params_recon[:senseMaps] = ComplexF32.(sensitivity[:, :, selected_slice, :]) # cannot avoid camel-case here since it is defined by MRIReco.jl and RegularizedLeastSquares.jl

if params_general[:do_correct_with_b0_map]
    params_recon[:correctionMap] = ComplexF32.(-1im .* resized_b0_maps[:, :, selected_slice]) # cannot avoid camel-case here since it is defined by MRIReco.jl and RegularizedLeastSquares.jl
end

#=
Finally we can call reconstruction function of the package `MRIReco.jl`
to perform final spiral image reconstruction.
=#
@info &quot;Performing Spiral Reconstruction&quot;
@time reco = reconstruction(imaging_acq_data, params_recon)

GC.gc() # Recommended to force triger garbage collection especially when encountering memory issues.</code></pre><p>Reorder slices of the reconstructed images to an ascending order</p><pre><code class="language- hljs">reco = reco[:,:,slice_idx_array_spiral[selected_slice]]
resized_b0_maps = resized_b0_maps[:, :, slice_idx_array_spiral[selected_slice]]</code></pre><h2 id=".-Save-and-Plot-the-Results-(Optional)"><a class="docs-heading-anchor" href="#.-Save-and-Plot-the-Results-(Optional)">4. Save and Plot the Results (Optional)</a><a id=".-Save-and-Plot-the-Results-(Optional)-1"></a><a class="docs-heading-anchor-permalink" href="#.-Save-and-Plot-the-Results-(Optional)" title="Permalink"></a></h2><p>All results could be saved into NIfTI files using the <code>save_map</code> function and be plotted using the <code>plot_reconstruction</code> function, both located in the file <a href="https://github.com/BRAIN-TO/GIRFReco.jl/blob/main/src/utils/utils.jl">utils.jl</a>.</p><pre><code class="language- hljs">if params_general[:do_save_recon]
    resolution_tmp = fieldOfView(imaging_acq_data)[1:2] ./ encodingSize(imaging_acq_data)
    resolution_mm = (resolution_tmp[1], resolution_tmp[2], fieldOfView(imaging_acq_data)[3] * (1 + params_general[:slice_distance_factor_percent] / 100.0)) #for 2D only, since FOV[3] is slice thickness then, but gap has to be observed
    num_slices = numSlices(imaging_acq_data)
    save_map(
        params_general[:recon_save_fullpath],
        params_general[:saving_scalefactor] * reco.data[:, :, slice_idx_array_spiral],
        resolution_mm;
        do_split_phase = true,
        do_normalize = params_general[:do_normalize_recon],
    )
end

if params_general[:do_plot_recon]
    @info &quot;Plotting Reconstruction&quot;
    plotlyjs()
    plot_reconstruction(
        reco,
        1:length(selected_slice),
        resized_b0_maps,
        is_slice_interleaved = false,
        rotation = 90,
    )
end

@info &quot;Successfully Completed Spiral Recon&quot;</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../Utilities/">« API</a><a class="docs-footer-nextpage" href="../recon_config_joss_demo/">GIRFReco.jl Example Configuration »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 24 July 2025 21:39">Thursday 24 July 2025</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
